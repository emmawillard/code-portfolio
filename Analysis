Method                           ArrayList Runtime     LinkedList Runtime    Explanation

boolean add(T element)            O(n)                  O(n)                Both ArrayList and LinkedList require going through entirety of list in worst case scenario. For array, at worst, must resize and copy the original list, but in most cases would be O(1).

boolean add(int index, T element) O(n)                  O(n)                Both ArrayList and LinkedList require going through entirety of list in worst case scenario.

void clear()                      O(1)                  O(1)                Both ArrayList and LinkedList simply create a new list, discard old list.

boolean contains(T element)       O(n)                  O(n)                Both ArrayList and LinkedList require going through entirety of list in its worst case.

T get(int index)                  O(1)                  O(n)                ArrayList simply checks and returns at index (does not run through entire list), while LinkedList must search through the entirety of the list to get to the correct index in the worst case.

int indexOf(T element)            O(n)                  O(n)                Both ArrayList and LinkedList require going through entirety of list in worst case, both search until element (if element is in list at all) is found.

boolean isEmpty()                 O(n)                  O(1)                ArrayList has to go through entirety of list, in worst case, to check for empty (null) space within its size. For LinkedList, the head is compared to null, which is a constant -- if head is null, list is null.

int lastIndexOf(T element)        O(n)                  O(n)                Similar to int indexOf(T element). Both ArrayList and LinkedList require going through entirety of list in worst case, both search until last instance of element (if element is in list at all) is found.

void set(int index, T element)    O(1)                  O(n)                ArrayList sets element at index easily, such as array[i] = element. In worst case for LinkedList, LinkedList must go through a for-loop to search for the index to set.

int size()                        O(n)                  O(n)                ArrayList must search through the entire list to sum the size. LinkedList loops with a counter to find its size.

void sort(boolean order)          O(n^2)                O(n^2)                My ArrayList uses Bubble Sort, which has two for-loops, making it O(n^2). My LinkedList creates a new sorted list, but must traverse entirety of list n*n times to find the next in order.

boolean remove(T element)         O(n)                  O(n)                Similar to int indexOf(T element), ArrayList and LinkedList require going through entirety of list in worst case scenario.

T remove(int index)               O(n)                  O(n)                ArrayList must go through a for-loop to check entirety of list to find, remove, and shift list. LinkedList uses one for-loop and is decently linear in structure, but may traverse entirety of list.

String toString()                 O(n)                  O(n)                Both ArrayList and LinkedList traverse the entirety of the list in order to return a string of the whole list.

Overall, each is more optimized in certain situations, but LinkedList seems to take less time on average and less code. However, I prefer ArrayList because its easier to use and visualize.